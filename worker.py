import grpc
import os
import sys
from concurrent import futures
import time
import json

# Assuming the existence of worker_pb2 and worker_pb2_grpc files generated by gRPC from .proto file
# These imports are necessary for gRPC communication
import worker_pb2
import worker_pb2_grpc
import driver_pb2
import driver_pb2_grpc

from utils import split_text_into_words, get_bucket_id, write_to_intermediate_file, read_intermediate_files, count_words, write_final_output
import config

class WorkerService(worker_pb2_grpc.WorkerServiceServicer):
    def __init__(self):
        self.task = None
        self.task_type = None
        self.task_id = None
        self.input_file = None
        self.intermediate_file = None
        self.output_file = None
        self.num_buckets = config.NUM_REDUCE_TASKS

    def RequestTask(self, request, context):
        # Communicate with the driver to get a task
        print("Requesting Task to Driver ...")
        channel = grpc.insecure_channel(f'{config.DRIVER_HOST}:{config.DRIVER_PORT}')
        stub = driver_pb2_grpc.MapReduceDriverStub(channel)
        response = stub.AssignTask(driver_pb2.AssignTaskRequest(worker_id=str(os.getpid())))
        self.task_type = response.task.type
        self.task_id = response.task.id
        self.input_file = response.task.filename
        self.task = response
        print("Driver answered ... ")
        # print(f"self.task_type: {self.task_type}")
        # print(f"self.task_id: {self.task_id}")
        # print(f"self.input_file: {self.input_file}")
        # return worker_pb2.TaskResponse(ack=True)

    def RequestCompleteTask(self):
        print(f"--> CompleteTaskRequest: ID {self.task_id} TYPE: {self.task_type}")
        channel = grpc.insecure_channel(f'{config.DRIVER_HOST}:{config.DRIVER_PORT}')
        stub = driver_pb2_grpc.MapReduceDriverStub(channel)
        task = driver_pb2.Task(type=self.task_type, id=self.task_id)
        response = stub.CompleteTask(driver_pb2.CompleteTaskRequest(task=task))
        print(f"--> CompleteTaskResponse: {response}")

    def PerformTask(self):
        print(f"Performing Task ID :{self.task_id} type: {self.task_type}")
        if self.task_type == 1:
            self.perform_map_task()
        elif self.task_type == 2:
            self.perform_reduce_task()
        else:
            print("No valid task assigned.")

    def perform_map_task(self):
        # Assuming the input files are named sequentially as 'input0.txt', 'input1.txt', ..., 'inputN.txt'
        input_file_path = self.input_file
        if not os.path.exists(input_file_path):
            print(f"No input file found for map task {self.task_id}")
            return
        with open(input_file_path, 'r') as file:
            text = file.read()
        
        words = split_text_into_words(text)
        for word in words:
            bucket_id = get_bucket_id(word, self.num_buckets)
            write_to_intermediate_file(self.task_id, bucket_id, [word])  
        self.RequestCompleteTask()
        

    def perform_reduce_task(self):
        print(f"Performing REDUCE TASK ID:{self.task_id}")
        words = read_intermediate_files(self.task_id, config.NUM_MAP_TASKS)
        word_counts = count_words(words)
        write_final_output(self.task_id, word_counts)
        self.RequestCompleteTask()


def main():
    worker = WorkerService()
    while True:
        worker.RequestTask(None, None)
        if worker.task_type is None:
            time.sleep(10)  # Wait for a bit before asking for a task again
        else:
            worker.PerformTask()
            print(f"Completed task with ID {worker.task_id} type :{worker.task_type} ")
            # Assuming the worker exits after completing a task for simplicity
            time.sleep(1)
if __name__ == '__main__':
    main()
